---
title: "Classification Trees"
author: "Niclas Frederic Sturm"
date: "3-11-2019"
output:
  pdf_document: default
  html_document:
    theme: yeti
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Dieses Dokument enthält die Programmierbefehle zur Erstellung von Modellen auf Basis von Entscheidungsbäumen. 

```{r message = FALSE}
library(readr)
library(dplyr)
library(rpart)
library(rpart.plot)
library(rsample)
library(Metrics)
library(ipred)
library(doParallel)
library(foreach)
library(stringr)
library(purrr)

set.seed(1997) # Set seed for reproducibility
setwd("/Users/nfsturm/Documents/STATLEARN/forestranger")

churn_data <- read_csv("employee_attrition.csv", col_names = TRUE)
drop_vars <- c("EmployeeCount", "EmployeeNumber")
churn_data <- churn_data %>%
  select(-drop_vars)

churn_data <- churn_data %>%
  mutate(Attrition = ifelse(Attrition == 'Yes', 1, 0))
```

Auch für Klassifikationsaufgaben entspricht das *Split-Train-Test*-Paradigma gegenwärtigen Standards. 

```{r}
churn_splits <- initial_split(churn_data)
test <- testing(churn_splits)
train <- training(churn_splits)
```

## Decision Trees

Die abhängige Variable - »Attrition« - wird nun zur Zielvariable eines einfachen Entscheidungsbaums. 

```{r}
tree_churn <- rpart(Attrition ~., data = train, method = "class")
```

Eine graphische Darstellung des Entscheidungsbaums zeigt, dass der Baum 13 verschiedene Kriterien zur Teilung verwendet. 

```{r}
rpart.plot(tree_churn, branch = 0.5, tweak = 1.5)
```

## Bagging 

```{r}
nbagg = c(5, 10, 15, 20, 25, 50, 100, 200, 300)

eval_df <- train %>%
  crossing(nbagg = c(5, 10, 15, 20, 25, 50, 100, 200, 300)) %>%
  group_by(nbagg) %>%
  nest(.key = "train") %>%
  mutate(model = map2(train, nbagg, .f = ~bagging(formula = Attrition~., data = .x, nbagg = .y)))

test_nested <- nest(test)
test_nested <- test_nested %>%
  crossing(1:length(nbagg)) %>%
  select(data)

colnames(test_nested) <- "test"

bound_df <- bind_cols(eval_df, test_nested)
bound_df <- bound_df %>%
  mutate(test_actual = map(test, ~.x$Attrition)) %>%
  mutate(test_predicted = map2(model, test, ~predict(.x, .y))) %>%
  mutate(test_predicted = map(test_predicted, ~round(.x, digits = 0))) %>%
  mutate(test_accuracy = map2_dbl(test_actual, test_predicted, ~accuracy(actual = .x, predicted = .y)))


```


## Boosting

## Random Forest

